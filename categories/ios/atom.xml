<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | JP Simard]]></title>
  <link href="https://jpsim.com/categories/ios/atom.xml" rel="self"/>
  <link href="https://jpsim.com/"/>
  <updated>2021-11-23T11:29:28-05:00</updated>
  <id>https://jpsim.com/</id>
  <author>
    <name><![CDATA[JP Simard]]></name>
    <email><![CDATA[jp@jpsim.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Uncovering SourceKit]]></title>
    <link href="https://jpsim.com/uncovering-sourcekit/"/>
    <updated>2014-07-06T16:07:00-04:00</updated>
    <id>https://jpsim.com/uncovering-sourcekit</id>
    <content type="html"><![CDATA[<p>To support a <a href="http://developer.apple.com/swift">fancy new language</a>, nifty <a href="https://developer.apple.com/library/prerelease/ios/recipes/xcode_help-source_editor/ExploringandEvaluatingSwiftCodeinaPlayground/ExploringandEvaluatingSwiftCodeinaPlayground.html">realtime IDE</a> features and impressive <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">cross-language interoperability</a>, Apple had to develop several new underlying tools. Here, we'll focus on <em>SourceKit</em>, Xcode's under-appreciated sidekick.</p>

<p><img src="/images/posts/sidekick.jpg" alt="sidekick" /></p>

<center><sub>SourceKitSidekick temporarily wearing a cape</sub></center>


<p><br/></p>

<h2>What is SourceKit?</h2>

<p>SourceKit is the set of tools that enables most of Swift's source code manipulation features: source code parsing, syntax highlighting, typesetting, autocomplete, cross-language header generation, and lots more.</p>

<h2>Architecture</h2>

<p>Xcode traditionally runs its compiler (<a href="http://clang.llvm.org">Clang</a>) <em>in-process</em>, which means that any time the compiler would crash, so would the IDE.</p>

<p><img src="/images/posts/house_of_cards.jpg" alt="house of cards" /></p>

<center><sub>Xcode architecture diagram</sub></center>


<p><br/></p>

<p>Exacerbating the problem, Xcode can easily invoke the compiler thousands of times to parse, highlight and typeset source code, all before a user ever hits <em>⌘+B</em>. That's because unlike most editors (Vim/Sublime/etc), Xcode doesn't use regular expressions to parse source code, but rather Clang's powerful (though much more complex) parser/tokenizer.</p>

<p>Thankfully, Swift in Xcode 6 moves away from this architecture<sup>1</sup>, combining all these source code manipulation features into a separate process that communicates with Xcode through <a href="https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/chapters/CreatingXPCServices.html">XPC</a>: <code>sourcekitd</code>. This XPC daemon is launched whenever Xcode 6 loads any Swift code.</p>

<p><img src="/images/posts/sourcekit_terminated.jpg" alt="sourcekit terminated" /></p>

<center><sub>Life would be miserable if Xcode crashed every time this appeared</sub></center>


<p><br/></p>

<h2>How Xcode uses SourceKit</h2>

<p>Since SourceKit is a private and undocumented tool, we need to get a little creative to learn how to use it. By setting the <code>SOURCEKIT_LOGGING</code><sup>2</sup> environment variable, Xcode will log its SourceKit communications to <code>stdout</code>, allowing us to monitor its communications in realtime. This is how many of the commands covered in this article were discovered.</p>

<h2>Unified Symbol Resolution</h2>

<p>SourceKit uses a Clang feature called the USR (Unified Symbol Resolution) as a unique identifier for a source code token (i.e. class, property, method, etc.). This is what allows you to <em>⌘+click</em> any token in Xcode and navigate to its definition. The USR is even more powerful now that it can unify a representation across languages (Swift/ObjC).</p>

<p><img src="/images/posts/usr.jpg" alt="usr" /></p>

<center><sub>The USR at work</sub></center>


<p><br/></p>

<p>To print the USR's from a Swift file (and their locations), you can run the following command:</p>

<pre><code>$ xcrun swift-ide-test -print-usrs -source-filename=Musician.swift
10:7 s:C14swift_ide_test8Musician
14:9 s:vC14swift_ide_test8Musician4nameSS
19:9 s:vC14swift_ide_test8Musician9birthyearSu
33:5 s:FC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_
33:10 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4nameSS
33:24 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_9birthyearSu
34:9 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4selfS0_
34:21 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4nameSS
35:9 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4selfS0_
35:26 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_9birthyearSu
</code></pre>

<h2>Swift<em>ish</em> header generation</h2>

<p><em>⌘+clicking</em> on a token defined in Objective-C from Swift will cause Xcode to trigger a Swift-like header to be generated. I say Swift-like because this generated file is not valid Swift<sup>3</sup>, but at least displays the Swift syntax equivalent to the Objective-C tokens.</p>

<p><a href="/images/posts/generated_swift_header.jpg"><img src="/images/posts/generated_swift_header.jpg" alt="Generated Swift Header" /></a></p>

<center><sub>Left: original Objective-C header. Right: SourceKit-generated Swift-ish version.</sub></center>


<p><br/></p>

<h2>Using SourceKit from the command line</h2>

<p><img src="/images/posts/sourcekit_playground.jpg" alt="SourceKit Playground" /></p>

<p>There are 3 main command line tools that allow to interact with SourceKit: <code>sourcekitd-test</code>, <code>swift-ide-test</code> and <code>swift</code>.</p>

<p>I compiled a shell script with documentation that runs through many useful commands like syntax highlighting, interface generation, AST parsing, demangling, and more.</p>

<p>The script is available on GitHub as a <a href="https://gist.github.com/jpsim/13971c81445219db1c63#file-sourcekit_playground-sh">gist</a>.</p>

<h2>3rd Party Tools Using SourceKit</h2>

<p>Because SourceKit lives outside of Xcode, it’s possible to leverage it to build anything from a Swift IDE to a documentation generator.</p>

<h3>jazzy<sup>♪♫</sup></h3>

<p><img src="/images/posts/jazzy.jpg" alt="jazzy" /></p>

<p><a href="https://github.com/realm/jazzy">jazzy</a> is a command-line utility that generates documentation for your Swift and Objective-C projects. It uses SourceKit to derive Swift syntax from Objective-C defined tokens (i.e. class, property, method, etc.).</p>

<h3>SwiftEdit</h3>

<p><a href="https://github.com/jpsim/SwiftEdit">SwiftEdit</a> is a proof-of-concept editor that supports syntax highlighting for Swift files.</p>

<p><img src="/images/posts/SwiftEdit.png" alt="SwiftEdit" /></p>

<h2>SourceKit &amp; You</h2>

<p>We’re just scratching the surface of what’s possible to build with SourceKit. Tools could be made to measure cross-language code coverage, or provide an editor where Objective-C and Swift can be edited simultaneously. Hopefully this article inspires you to build something with SourceKit and improve our tools in the process.</p>

<hr />

<p><em>1: Objective-C in Xcode 6 (Beta 2) doesn't use SourceKit at all, keeping Xcode's traditional clang-in-process architecture. I expect this to change before Xcode 6 GM.</em></p>

<p><em>2: For SourceKit logging, launch Xcode with <sub><code>export SOURCEKIT_LOGGING=3 &amp;&amp; /Applications/Xcode6-Beta2.app/Contents/MacOS/Xcode</code></sub></em></p>

<p><em>3: Speculation: I expect private Swift modules to expose public interfaces using a similar syntax once the language has <a href="https://github.com/ksm/SwiftInFlux#access-control">access control mechanisms</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SF Swift Meetup]]></title>
    <link href="https://jpsim.com/sf-swift-meetup/"/>
    <updated>2014-06-27T14:58:00-04:00</updated>
    <id>https://jpsim.com/sf-swift-meetup</id>
    <content type="html"><![CDATA[<p>I recently gave a talk on <a href="https://developer.apple.com/swift">Swift</a> at the <a href="http://www.meetup.com/swift-language">SF/SV Swift Language User Group</a> meetup. We've made the whole thing available online:</p>

<ul>
<li><a href="http://realm.io/news/swift-unchartered-territory-swift-intro-and-internals">Video</a></li>
<li><a href="https://speakerdeck.com/jpsim/swift-uncharted-territory">Slides</a></li>
<li><a href="https://github.com/jpsim/talks">Slides Source</a></li>
</ul>


<p>The first half of the talk covers the basic features and syntax of the language. The rest of the talk touches on some more in-depth discoveries about the runtime, introspection and how the tools work behind the scenes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPSThumbnailAnnotation updated for iOS 7]]></title>
    <link href="https://jpsim.com/jpsthumbnailannotation-updated-for-ios-7/"/>
    <updated>2014-03-27T11:55:00-04:00</updated>
    <id>https://jpsim.com/jpsthumbnailannotation-updated-for-ios-7</id>
    <content type="html"><![CDATA[<p>I've just given a fresh coat of iOS7-flavoured paint to my most popular open-source library: JPSThumbnailAnnotation.</p>

<p>Check it out on <a href="https://github.com/jpsim/JPSThumbnailAnnotation">GitHub</a> or just add it to CocoaPods: <code>pod 'JPSThumbnailAnnotation'</code>.</p>

<p><img src="https://github.com/jpsim/JPSThumbnailAnnotation/raw/master/screenshots2.jpg" alt="Screenshots" /></p>

<p>I decided not to maintain the iOS 6 <em>style</em>, but iOS 6 is still supported.</p>

<p>By the way, this is what the old style looked like. It's still in git, if you need to find it for some reason.</p>

<p><img src="https://github.com/jpsim/JPSThumbnailAnnotation/raw/master/screenshots.jpg" alt="Old Screenshots" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keyboard Layout Guide]]></title>
    <link href="https://jpsim.com/keyboard-layout-guide/"/>
    <updated>2014-03-26T14:41:00-04:00</updated>
    <id>https://jpsim.com/keyboard-layout-guide</id>
    <content type="html"><![CDATA[<p>I really like iOS 7's <code>topLayoutGuide</code> and <code>bottomLayoutGuide</code>. They're immensely useful. But in my adventures with Auto Layout, I've often wished that Apple had added a third member to this exclusive group: a sort of <code>keyboardLayoutGuide</code>.</p>

<p>It's a bit of a drag to have to set up <code>NSNotification</code> observers just to be able to keep your textfield on the screen when the keyboard barges into view. So I added a <code>keyboardLayoutGuide</code> to <code>UIViewController</code> myself. You can check it out on GitHub here: <a href="https://github.com/jpsim/JPSKeyboardLayoutGuide">jpsim/JPSKeyboardLayoutGuide</a>.</p>

<p>If you've used Apple's layout guides before, you'll know that they're actually just <code>id</code>'s that conform to the <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UILayoutSupport_Protocol/Reference/Reference.html"><code>UILayoutSupport</code> Protocol</a>. So I figured that having the guide just be a zero-sized UIView was probably the best way to go. This way, I can easily add it to the view and bind it to the keyboard frame by modifying a constraint's constant.</p>

<p>In all honesty, I dislike the inheritance approach I took here; it seems like the easy way out. I'm hoping that either myself or a contributor will have a stroke of genius and find a composition-based way to do this. Perhaps a starting point would be a category on <code>UIViewController</code> along with an associated object as the <code>keyboardLayoutGuide</code> property... But then the <code>NSNotification</code>s will be troublesome. If you have an idea, please fork and send a PR or open up an issue on <a href="https://github.com/jpsim/JPSKeyboardLayoutGuide">github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Private Pods]]></title>
    <link href="https://jpsim.com/private-pods/"/>
    <updated>2014-03-17T19:12:00-04:00</updated>
    <id>https://jpsim.com/private-pods</id>
    <content type="html"><![CDATA[<p>Keeping a project modular is a lofty software development goal that we all strive for even though it can never be fully attained.</p>

<p>One way to encourage a modular architecture is to use a dependency manager like <a href="http://cocoapods.org">Cocoapods</a>. I've blogged about using Cocoapods <a href="/cocoapods-tips-tricks">before</a>, but I didn't touch on splitting up portions of your code that wouldn't benefit from being open-sourced. Either because they're too application-specific, or they're proprietary.</p>

<p>For example, say you were building an application backed by a private web API, that needed to persist data to disk. A naïve implementation (<em>read what <strong>most</strong> of us would do, including myself</em>) would combine UI, API and persistence all in one project/workspace. In a fully modular app, UI/API/persistence would all have some degree of separation.</p>

<p>Private pods go a long way to help split up your codebase into logical modules. This becomes especially valuable in medium-large projects with 10k+ lines of code.</p>

<p>There are two main ways to make a private pod: remote and local.</p>

<h3>Remote</h3>

<p>You can either create a Specs-like private repo as indicated in <a href="http://guides.cocoapods.org/making/private-cocoapods.html">this official Cocoapods guide</a> or you can host your <code>.podspec</code> online and reference it directly in your <code>Podfile</code>.</p>

<p>Here's how you'd reference it directly in a <code>Podfile</code>:</p>

<pre><code class="ruby">pod 'PrivatePod', :podspec =&gt; 'https://github.com/jpsim/JPSDisplayLink/raw/master/JPSDisplayLink.podspec'
</code></pre>

<h3>Local</h3>

<p>Though I find it unlikely, it might make sense to keep your private pods in the same repo as your project. In which case, you'd commit all its code in a special folder (i.e. <code>local_pods/POD_NAME</code>) and you'd specify the podspec path in your <code>Podfile</code>.</p>

<pre><code class="ruby">pod 'PrivatePod', :path =&gt; 'local_pods/PrivatePod'
</code></pre>

<p>In this case, the <code>.podspec</code> would be located at <code>local_pods/PrivatePod/PrivatePod.podspec</code>.</p>

<p><em>Note: I've had inconsistent results writing local podspecs. Specs that worked perfectly in a remote repo didn't work at all locally for no apparent reason. Your mileage may vary, I might have made a stupid mistake.</em></p>

<h2>Word of caution</h2>

<p>Splitting up your codebase is not something you should do for its own sake. The additional overhead probably won't be worthwhile in smaller projects. But the larger the project, the bigger the gain.</p>

<p>On that note, I hope this article helps you decide how you want to split your monolithic 300k line app. But hey, you could always build static libraries instead (<em>cue laughter</em>).</p>
]]></content>
  </entry>
  
</feed>
