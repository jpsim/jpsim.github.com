<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projects | JP Simard]]></title>
  <link href="https://jpsim.com/categories/projects/atom.xml" rel="self"/>
  <link href="https://jpsim.com/"/>
  <updated>2018-11-29T13:54:18-08:00</updated>
  <id>https://jpsim.com/</id>
  <author>
    <name><![CDATA[JP Simard]]></name>
    <email><![CDATA[jp@jpsim.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evaluating SwiftSyntax for use in SwiftLint]]></title>
    <link href="https://jpsim.com/evaluating-swiftsyntax-for-use-in-swiftlint/"/>
    <updated>2018-11-22T14:50:00-08:00</updated>
    <id>https://jpsim.com/evaluating-swiftsyntax-for-use-in-swiftlint</id>
    <content type="html"><![CDATA[<p><strong>tl;dr; Implementing SwiftLint using SwiftSyntax instead of SourceKitten would make it run over 20x slower ðŸ˜­</strong></p>

<p><strong>Update:</strong> Since writing this post, I learnt that SwiftSyntax's upcoming byte tree deserialization mode will speed this up considerably.
I hope to post a follow-up article on this shortly.</p>

<p>I have for some time been looking forward to reimplementing some of <a href="https://github.com/realm/SwiftLint">SwiftLint</a>'s simpler syntax-only rules with <a href="https://github.com/apple/swift-syntax">SwiftSyntax</a>. If you're not familiar with it, the recent <a href="https://nshipster.com/swiftsyntax/">NSHipster article</a> gives a great overview. My motivation for integrating it into SwiftLint was that it would be nice to use an officially maintained library directly to obtain the syntax tree rather than the open source but community-maintained <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a> library. I was also under the false impression that SwiftSyntax would be significantly faster than SourceKit/SourceKitten.</p>

<p>SourceKitten gets its syntax tree by dynamically loading <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">SourceKit</a> and making cross-process XPC calls to a SourceKit daemon. In a typical uncached lint run, SwiftLint spends a significant amount of time waiting on this syntax tree for each file being linted. Because SwiftSyntax is <a href="https://github.com/apple/swift-syntax#building-swiftsyntax-from-master">code-generated</a> from the same syntax definition files as the Swift compiler, I had (incorrectly) assumed that calculating a Swift file's syntax tree using SwiftSyntax was done entirely in-process by the library, which would have lead to significant performance gains by avoiding the cross-process XPC call made by SourceKitten for equivalent functionality.</p>

<p>In reality, SwiftSyntax delegates all parsing &amp; lexing to the <code>swiftc</code> binary, <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L100-L101">launching the process</a>, <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L102">reading its output from stdout</a> and <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L103-L104">deserializing the JSON response</a> into its <code>SourceFileSyntax</code> Swift type. This is repeated for each file being parsed ðŸ˜±.</p>

<p><strong>Launching a new instance of the Swift compiler for each file parsed is orders of magnitude slower than SourceKitten's XPC call to a long-lived SourceKit daemon.</strong></p>

<p>I discovered this after <a href="https://github.com/realm/SwiftLint/pull/2476">reimplementing</a> a very simple SwiftLint rule with a SwiftSyntax-based implementation: <a href="https://github.com/realm/SwiftLint/blob/master/Rules.md#fallthrough">Fallthrough</a>. This opt-in rule is a perfect proof-of-concept for integrating SwiftSyntax into SwiftLint because it literally just finds all occurrences of the <code>fallthrough</code> keyword and reports a violation at that location. I measured the time it took to lint a folder of ~100 Swift files from Lyft's iOS codebase with only the <code>fallthrough</code> rule whitelisted.</p>

<pre><code class="yaml"># .swiftlint.yml configuration file
included:
  - path/to/lint/dir # contains ~100 Swift files
whitelist_rules:
  - fallthrough
</code></pre>

<p>I compiled both SwiftLint from <code>master</code> and again with this <code>fallthrough-swift-syntax</code> branch with <code>swift build -c release</code> and named the binaries <code>swiftlint-master</code> and <code>swiftlint-swift-syntax</code>. I then benchmarked both binaries using the excellent <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> utility.</p>

<pre><code class="shell">$ hyperfine './swiftlint-master lint --quiet --no-cache' './swiftlint-swift-syntax lint --quiet --no-cache'
Benchmark #1: ./swiftlint-master lint --quiet --no-cache
  Time (mean Â± Ïƒ):     231.3 ms Â±   5.1 ms    [User: 130.5 ms, System: 29.2 ms]
  Range (min â€¦ max):   224.3 ms â€¦ 238.3 ms

Benchmark #2: ./swiftlint-swift-syntax lint --quiet --no-cache
  Time (mean Â± Ïƒ):      5.254 s Â±  0.149 s    [User: 20.309 s, System: 23.110 s]
  Range (min â€¦ max):    4.839 s â€¦  5.354 s

Summary
  './swiftlint-master lint --quiet --no-cache' ran
   22.71 Â± 0.82 times faster than './swiftlint-swift-syntax lint --quiet --no-cache'
</code></pre>

<p><strong>The SwiftSyntax version was 22x slower than the existing SourceKitten version</strong></p>

<p><em>Note that I ran SwiftLint with its caching mechanism and logging disabled to accurately measure the time it took just to perform the lint, rather than the overhead from logging or skipping the lint entirely by just returning cached results. Although logging only added 3ms to 10ms in my tests.</em></p>

<hr />

<p>Ultimately, this means SwiftLint will be keeping its SourceKitten-based implementation for the foreseeable future, unless SwiftSyntax removes its reliance on costly compiler invocations and drastically improves its performance. I really hope the Swift team can somehow find a way to move parsing and lexing into SwiftSyntax itself, making the library much more appealing to use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Yams 1.0]]></title>
    <link href="https://jpsim.com/introducing-yams-1-dot-0/"/>
    <updated>2018-05-19T11:40:00-07:00</updated>
    <id>https://jpsim.com/introducing-yams-1-dot-0</id>
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jpsim/Yams/master/yams.jpg" alt="Yams: A Sweet &amp; Swifty YAML Parser" /></p>

<p><a href="https://twitter.com/norio_nomura">Norio Nomura</a> and I (ok, honestly mostly Norio ðŸ˜…) have been building a
Swift library for encoding &amp; decoding <a href="http://yaml.org">YAML</a> for the last 18 months and
it's now stable enough to make a 1.0 release and share with the world.</p>

<p>It's called Yams, you can find it on GitHub at <a href="https://github.com/jpsim/Yams">jpsim/Yams</a> and API
docs are located at <a href="https://jpsim.com/Yams">jpsim.com/Yams</a>.</p>

<p>You could say it's a Swift binding for <a href="https://github.com/yaml/libyaml">LibYAML</a> but I'd argue it's
much more than that.</p>

<p>I'm actually very happy with how this library ended up. It plays nicely with
Swift 4's <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">Codable protocol</a>, meaning that you get fast &amp; type-safe
encoding &amp; decoding that feels right at home in modern Swift.</p>

<p>Here's a simple example of encoding &amp; decoding <code>Codable</code> types:</p>

<pre><code class="swift">import Yams

struct S: Codable {
  var p: String
}

let s = S(p: "test")
let encoder = YAMLEncoder()
let encodedYAML = try encoder.encode(s)
encodedYAML == """
  p: test

  """
let decoder = YAMLDecoder()
let decoded = try decoder.decode(S.self, from: encodedYAML)
s.p == decoded.p
</code></pre>

<p>Alternatively, you can use it to work with Swift scalar &amp; collection types,
which is probably the easiest way to start parsing arbitrary YAML for your
projects. Finally, there's a third mode, which is a Yams-native API that best
translates to how LibYAML works.</p>

<p>This library's been powering a number of popular projects that use YAML for
configuration, like <a href="https://github.com/realm/SwiftLint">SwiftLint</a>, <a href="https://github.com/SwiftGen/SwiftGen">SwiftGen</a>,
<a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a> &amp; used in <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a> to parse Swift
Package Manager build manifests. So if you've wanted to add YAML configuration
files to your Swift CLI, or want to interoperate with other tools that process
YAML, I encourage you to give Yams a try.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a serverless password-protected photo gallery]]></title>
    <link href="https://jpsim.com/awspics/"/>
    <updated>2017-07-04T06:14:00-07:00</updated>
    <id>https://jpsim.com/awspics</id>
    <content type="html"><![CDATA[<p>Building a serverless photo gallery?
<em>Easy!</em>
Password-protecting that without adding servers?
<em>Surprisingly much more complex.</em></p>

<p><img src="https://github.com/jpsim/AWSPics/raw/master/assets/awspics.gif" alt="" /></p>

<h2>Goals</h2>

<blockquote><p>Host a self-contained, declarative infrastructure, password-protected,
data-driven static photo gallery to share personal pictures with friends and
family, without needing to run, maintain (or pay for) servers.</p></blockquote>

<p>With <a href="https://twitter.com/simjp/status/873604866043543552">the recent addition</a>
to our family, I wanted to set up a place where I could share pictures with
our closest friends and family. Facebook wasn't an option because...
<a href="https://daringfireball.net/2017/06/fuck_facebook">yeah</a>,
<a href="http://www.slate.com/articles/technology/data_mine_1/2013/09/facebook_privacy_and_kids_don_t_post_photos_of_your_kids_online.html">because</a>
<a href="http://www.telegraph.co.uk/women/family/i-dont-put-pictures-of-my-children-on-facebook---and-you-shouldn/">many</a>
<a href="http://www.huffingtonpost.com.au/2016/02/07/can-i-post-photos-of-other-peoples-children_n_9184560.html">reasons</a>
<a href="https://medium.com/matter/beware-your-baby-s-face-is-online-and-on-sale-d33ae8cdaa9d">actually</a>.</p>

<p>Most of my family members are on Apple devices, while most of my friends are in
the Google/Android ecosystem. So for day to day sharing of moments, we post a
few pictures to iCloud photo sharing, and a few others to a WhatsApp group. But
neither of these can really serve as the canonical place where we're storing
these photos long-term, because WhatsApp is pretty ephemeral, and the iCloud
photo sharing experience <em>sucks</em> on non-Apple devices.</p>

<h2>Architecture</h2>

<p>Unfortunately there's no "put a password in front of AWS CloudFront" checkbox.
I wish there were, so I wouldn't have had to build this. But there isn't, so it
was time to roll up my sleeves and learn a bit about how modern web
infrastructure is built. Or at least my idea of it.</p>

<p><img src="https://github.com/jpsim/AWSPics/raw/master/assets/architecture.png" alt="" /></p>

<p>There are 7 main components:</p>

<ol>
<li><strong>CloudFront with restricted bucket access</strong> to prevent unauthenticated
access to the site or its pictures.</li>
<li><strong>Login lambda function</strong> to validate authentication and sign cookies to
allow access to restricted buckets.</li>
<li><strong>Source S3 bucket</strong> to store original pictures and metadata driving the
site.</li>
<li><strong>Resized S3 bucket</strong> to store resized versions of the original pictures.</li>
<li><strong>Web S3 bucket</strong> to store the static website generated from the data in the
source bucket.</li>
<li><strong>Resize lambda function</strong> to automatically resize images added to the source
S3 bucket and store them in the resized S3 bucket.</li>
<li><strong>Site builder lambda function</strong> to automatically rebuild the static website
when changes are made to the source S3 bucket.</li>
</ol>


<h2>Can it be simplified?</h2>

<p>Of course. There are a few ways I can think of to simplify this, but the
tradeoffs aren't worthwhile IMO.</p>

<ol>
<li><strong>Resize images on demand.</strong> Rather than resize all the images when they're
first added to the source bucket, the resize lambda could be exposed via a
CloudFront origin. However, since the static site only really uses two
image sizes, and that lambda functions have a significant
<a href="https://serverless.com/blog/keep-your-lambdas-warm/">cold start penalty</a>,
it's much more efficient to just precompute the resized images.</li>
<li><strong>Consolidate buckets.</strong>  Rather than separate source, resized &amp; web buckets,
they could just be in a single bucket. However, this would just shift the
complexity a bit since the stack would then need to filter new object
notifications to know which function to invoke. Plus, right now to back up
the valuable content, I just need to periodically mirror the source bucket,
rather than all the derivative data in the resized and web buckets.</li>
</ol>


<h2>Problems?</h2>

<p>I have a few annoyances with this setup as-is.</p>

<p>One is that only the resized bucket triggers the site builder function. That
means that any other object modified in the source bucket, such as the
<code>metadata.yml</code> files that include album comments, don't trigger a site build.</p>

<p>Another related problem is that for every new image in the source bucket, two
are created in the resized bucket, each one invoking the site builder function.
Not only that, but if I upload an album with lots of pictures all in one shot,
the site will be rebuilt twice for each picture! ðŸ™€</p>

<p>Unfortunately, S3 buckets can only have a
<a href="https://stackoverflow.com/q/31471178/373262">single notification per event type</a>,
so we can't trigger both the resize and site builder functions when new objects
are created on the source bucket.</p>

<p>I think the solution here would involve
<a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html">publishing S3 events to SNS or SQS</a>
and "debouncing" the site builder lambda, but again... <strong>#complexity</strong>.</p>

<p><img src="https://media.giphy.com/media/mYqaRkXyoGbcY/giphy.gif" alt="" /></p>

<p>I'll probably do this eventually, but I'm in no hurry.</p>

<h2>Code</h2>

<p>I've open sourced the entire AWS stack on GitHub over at
<a href="https://github.com/jpsim/AWSPics">jpsim/AWSPics</a>. I'm also hosting a demo
site over at <a href="https://awspics.net">awspics.net</a> (use "username"/"password" as
credentials to check it out).</p>

<p>There's a (long) video walkthrough <a href="https://youtu.be/010AGcY4uoE">on YouTube</a>
too, if that's useful to follow along.</p>

<h2>Closing Thoughts</h2>

<p>Overall, I really enjoyed stepping outside my comfort zone of native
Swift/ObjC/C++ programming, learning a TON about several AWS services and
ultimately meeting my goal of setting up a private photo gallery.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">If you think incremental Xcode builds take a while, try deploying changes to an AWS CloudFormation stack ðŸ˜… <a href="https://t.co/yTPsqarT92">pic.twitter.com/yTPsqarT92</a></p>&mdash; JP Simard (@simjp) <a href="https://twitter.com/simjp/status/881640404851884033">July 2, 2017</a></blockquote>


<script async src="https://jpsim.com//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPSThumbnailAnnotation updated for iOS 7]]></title>
    <link href="https://jpsim.com/jpsthumbnailannotation-updated-for-ios-7/"/>
    <updated>2014-03-27T11:55:00-07:00</updated>
    <id>https://jpsim.com/jpsthumbnailannotation-updated-for-ios-7</id>
    <content type="html"><![CDATA[<p>I've just given a fresh coat of iOS7-flavoured paint to my most popular open-source library: JPSThumbnailAnnotation.</p>

<p>Check it out on <a href="https://github.com/jpsim/JPSThumbnailAnnotation">GitHub</a> or just add it to CocoaPods: <code>pod 'JPSThumbnailAnnotation'</code>.</p>

<p><img src="https://github.com/jpsim/JPSThumbnailAnnotation/raw/master/screenshots2.jpg" alt="Screenshots" /></p>

<p>I decided not to maintain the iOS 6 <em>style</em>, but iOS 6 is still supported.</p>

<p>By the way, this is what the old style looked like. It's still in git, if you need to find it for some reason.</p>

<p><img src="https://github.com/jpsim/JPSThumbnailAnnotation/raw/master/screenshots.jpg" alt="Old Screenshots" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keyboard Layout Guide]]></title>
    <link href="https://jpsim.com/keyboard-layout-guide/"/>
    <updated>2014-03-26T14:41:00-07:00</updated>
    <id>https://jpsim.com/keyboard-layout-guide</id>
    <content type="html"><![CDATA[<p>I really like iOS 7's <code>topLayoutGuide</code> and <code>bottomLayoutGuide</code>. They're immensely useful. But in my adventures with Auto Layout, I've often wished that Apple had added a third member to this exclusive group: a sort of <code>keyboardLayoutGuide</code>.</p>

<p>It's a bit of a drag to have to set up <code>NSNotification</code> observers just to be able to keep your textfield on the screen when the keyboard barges into view. So I added a <code>keyboardLayoutGuide</code> to <code>UIViewController</code> myself. You can check it out on GitHub here: <a href="https://github.com/jpsim/JPSKeyboardLayoutGuide">jpsim/JPSKeyboardLayoutGuide</a>.</p>

<p>If you've used Apple's layout guides before, you'll know that they're actually just <code>id</code>'s that conform to the <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UILayoutSupport_Protocol/Reference/Reference.html"><code>UILayoutSupport</code> Protocol</a>. So I figured that having the guide just be a zero-sized UIView was probably the best way to go. This way, I can easily add it to the view and bind it to the keyboard frame by modifying a constraint's constant.</p>

<p>In all honesty, I dislike the inheritance approach I took here; it seems like the easy way out. I'm hoping that either myself or a contributor will have a stroke of genius and find a composition-based way to do this. Perhaps a starting point would be a category on <code>UIViewController</code> along with an associated object as the <code>keyboardLayoutGuide</code> property... But then the <code>NSNotification</code>s will be troublesome. If you have an idea, please fork and send a PR or open up an issue on <a href="https://github.com/jpsim/JPSKeyboardLayoutGuide">github</a>!</p>
]]></content>
  </entry>
  
</feed>
