<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | JP Simard]]></title>
  <link href="https://jpsim.com/categories/swift/atom.xml" rel="self"/>
  <link href="https://jpsim.com/"/>
  <updated>2021-11-23T11:29:28-05:00</updated>
  <id>https://jpsim.com/</id>
  <author>
    <name><![CDATA[JP Simard]]></name>
    <email><![CDATA[jp@jpsim.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evaluating SwiftSyntax for use in SwiftLint]]></title>
    <link href="https://jpsim.com/evaluating-swiftsyntax-for-use-in-swiftlint/"/>
    <updated>2018-11-22T14:50:00-05:00</updated>
    <id>https://jpsim.com/evaluating-swiftsyntax-for-use-in-swiftlint</id>
    <content type="html"><![CDATA[<p><strong>tl;dr; Implementing SwiftLint using SwiftSyntax instead of SourceKitten would make it run over 20x slower ðŸ˜­</strong></p>

<p><strong>Update:</strong> Since writing this post, I learnt that SwiftSyntax's upcoming byte tree deserialization mode will speed this up considerably.
I hope to post a follow-up article on this shortly.</p>

<p>I have for some time been looking forward to reimplementing some of <a href="https://github.com/realm/SwiftLint">SwiftLint</a>'s simpler syntax-only rules with <a href="https://github.com/apple/swift-syntax">SwiftSyntax</a>. If you're not familiar with it, the recent <a href="https://nshipster.com/swiftsyntax/">NSHipster article</a> gives a great overview. My motivation for integrating it into SwiftLint was that it would be nice to use an officially maintained library directly to obtain the syntax tree rather than the open source but community-maintained <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a> library. I was also under the false impression that SwiftSyntax would be significantly faster than SourceKit/SourceKitten.</p>

<p>SourceKitten gets its syntax tree by dynamically loading <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">SourceKit</a> and making cross-process XPC calls to a SourceKit daemon. In a typical uncached lint run, SwiftLint spends a significant amount of time waiting on this syntax tree for each file being linted. Because SwiftSyntax is <a href="https://github.com/apple/swift-syntax#building-swiftsyntax-from-master">code-generated</a> from the same syntax definition files as the Swift compiler, I had (incorrectly) assumed that calculating a Swift file's syntax tree using SwiftSyntax was done entirely in-process by the library, which would have lead to significant performance gains by avoiding the cross-process XPC call made by SourceKitten for equivalent functionality.</p>

<p>In reality, SwiftSyntax delegates all parsing &amp; lexing to the <code>swiftc</code> binary, <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L100-L101">launching the process</a>, <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L102">reading its output from stdout</a> and <a href="https://github.com/apple/swift-syntax/blob/0.40200.0/Sources/SwiftSyntax/SwiftSyntax.swift#L103-L104">deserializing the JSON response</a> into its <code>SourceFileSyntax</code> Swift type. This is repeated for each file being parsed ðŸ˜±.</p>

<p><strong>Launching a new instance of the Swift compiler for each file parsed is orders of magnitude slower than SourceKitten's XPC call to a long-lived SourceKit daemon.</strong></p>

<p>I discovered this after <a href="https://github.com/realm/SwiftLint/pull/2476">reimplementing</a> a very simple SwiftLint rule with a SwiftSyntax-based implementation: <a href="https://github.com/realm/SwiftLint/blob/master/Rules.md#fallthrough">Fallthrough</a>. This opt-in rule is a perfect proof-of-concept for integrating SwiftSyntax into SwiftLint because it literally just finds all occurrences of the <code>fallthrough</code> keyword and reports a violation at that location. I measured the time it took to lint a folder of ~100 Swift files from Lyft's iOS codebase with only the <code>fallthrough</code> rule whitelisted.</p>

<pre><code class="yaml"># .swiftlint.yml configuration file
included:
  - path/to/lint/dir # contains ~100 Swift files
whitelist_rules:
  - fallthrough
</code></pre>

<p>I compiled both SwiftLint from <code>master</code> and again with this <code>fallthrough-swift-syntax</code> branch with <code>swift build -c release</code> and named the binaries <code>swiftlint-master</code> and <code>swiftlint-swift-syntax</code>. I then benchmarked both binaries using the excellent <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> utility.</p>

<pre><code class="shell">$ hyperfine './swiftlint-master lint --quiet --no-cache' './swiftlint-swift-syntax lint --quiet --no-cache'
Benchmark #1: ./swiftlint-master lint --quiet --no-cache
  Time (mean Â± Ïƒ):     231.3 ms Â±   5.1 ms    [User: 130.5 ms, System: 29.2 ms]
  Range (min â€¦ max):   224.3 ms â€¦ 238.3 ms

Benchmark #2: ./swiftlint-swift-syntax lint --quiet --no-cache
  Time (mean Â± Ïƒ):      5.254 s Â±  0.149 s    [User: 20.309 s, System: 23.110 s]
  Range (min â€¦ max):    4.839 s â€¦  5.354 s

Summary
  './swiftlint-master lint --quiet --no-cache' ran
   22.71 Â± 0.82 times faster than './swiftlint-swift-syntax lint --quiet --no-cache'
</code></pre>

<p><strong>The SwiftSyntax version was 22x slower than the existing SourceKitten version</strong></p>

<p><em>Note that I ran SwiftLint with its caching mechanism and logging disabled to accurately measure the time it took just to perform the lint, rather than the overhead from logging or skipping the lint entirely by just returning cached results. Although logging only added 3ms to 10ms in my tests.</em></p>

<hr />

<p>Ultimately, this means SwiftLint will be keeping its SourceKitten-based implementation for the foreseeable future, unless SwiftSyntax removes its reliance on costly compiler invocations and drastically improves its performance. I really hope the Swift team can somehow find a way to move parsing and lexing into SwiftSyntax itself, making the library much more appealing to use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Yams 1.0]]></title>
    <link href="https://jpsim.com/introducing-yams-1-dot-0/"/>
    <updated>2018-05-19T11:40:00-04:00</updated>
    <id>https://jpsim.com/introducing-yams-1-dot-0</id>
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/jpsim/Yams/master/yams.jpg" alt="Yams: A Sweet &amp; Swifty YAML Parser" /></p>

<p><a href="https://twitter.com/norio_nomura">Norio Nomura</a> and I (ok, honestly mostly Norio ðŸ˜…) have been building a
Swift library for encoding &amp; decoding <a href="http://yaml.org">YAML</a> for the last 18 months and
it's now stable enough to make a 1.0 release and share with the world.</p>

<p>It's called Yams, you can find it on GitHub at <a href="https://github.com/jpsim/Yams">jpsim/Yams</a> and API
docs are located at <a href="https://jpsim.com/Yams">jpsim.com/Yams</a>.</p>

<p>You could say it's a Swift binding for <a href="https://github.com/yaml/libyaml">LibYAML</a> but I'd argue it's
much more than that.</p>

<p>I'm actually very happy with how this library ended up. It plays nicely with
Swift 4's <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">Codable protocol</a>, meaning that you get fast &amp; type-safe
encoding &amp; decoding that feels right at home in modern Swift.</p>

<p>Here's a simple example of encoding &amp; decoding <code>Codable</code> types:</p>

<pre><code class="swift">import Yams

struct S: Codable {
  var p: String
}

let s = S(p: "test")
let encoder = YAMLEncoder()
let encodedYAML = try encoder.encode(s)
encodedYAML == """
  p: test

  """
let decoder = YAMLDecoder()
let decoded = try decoder.decode(S.self, from: encodedYAML)
s.p == decoded.p
</code></pre>

<p>Alternatively, you can use it to work with Swift scalar &amp; collection types,
which is probably the easiest way to start parsing arbitrary YAML for your
projects. Finally, there's a third mode, which is a Yams-native API that best
translates to how LibYAML works.</p>

<p>This library's been powering a number of popular projects that use YAML for
configuration, like <a href="https://github.com/realm/SwiftLint">SwiftLint</a>, <a href="https://github.com/SwiftGen/SwiftGen">SwiftGen</a>,
<a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a> &amp; used in <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a> to parse Swift
Package Manager build manifests. So if you've wanted to add YAML configuration
files to your Swift CLI, or want to interoperate with other tools that process
YAML, I encourage you to give Yams a try.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Uncovering SourceKit]]></title>
    <link href="https://jpsim.com/uncovering-sourcekit/"/>
    <updated>2014-07-06T16:07:00-04:00</updated>
    <id>https://jpsim.com/uncovering-sourcekit</id>
    <content type="html"><![CDATA[<p>To support a <a href="http://developer.apple.com/swift">fancy new language</a>, nifty <a href="https://developer.apple.com/library/prerelease/ios/recipes/xcode_help-source_editor/ExploringandEvaluatingSwiftCodeinaPlayground/ExploringandEvaluatingSwiftCodeinaPlayground.html">realtime IDE</a> features and impressive <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">cross-language interoperability</a>, Apple had to develop several new underlying tools. Here, we'll focus on <em>SourceKit</em>, Xcode's under-appreciated sidekick.</p>

<p><img src="/images/posts/sidekick.jpg" alt="sidekick" /></p>

<center><sub>SourceKitSidekick temporarily wearing a cape</sub></center>


<p><br/></p>

<h2>What is SourceKit?</h2>

<p>SourceKit is the set of tools that enables most of Swift's source code manipulation features: source code parsing, syntax highlighting, typesetting, autocomplete, cross-language header generation, and lots more.</p>

<h2>Architecture</h2>

<p>Xcode traditionally runs its compiler (<a href="http://clang.llvm.org">Clang</a>) <em>in-process</em>, which means that any time the compiler would crash, so would the IDE.</p>

<p><img src="/images/posts/house_of_cards.jpg" alt="house of cards" /></p>

<center><sub>Xcode architecture diagram</sub></center>


<p><br/></p>

<p>Exacerbating the problem, Xcode can easily invoke the compiler thousands of times to parse, highlight and typeset source code, all before a user ever hits <em>âŒ˜+B</em>. That's because unlike most editors (Vim/Sublime/etc), Xcode doesn't use regular expressions to parse source code, but rather Clang's powerful (though much more complex) parser/tokenizer.</p>

<p>Thankfully, Swift in Xcode 6 moves away from this architecture<sup>1</sup>, combining all these source code manipulation features into a separate process that communicates with Xcode through <a href="https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/chapters/CreatingXPCServices.html">XPC</a>: <code>sourcekitd</code>. This XPC daemon is launched whenever Xcode 6 loads any Swift code.</p>

<p><img src="/images/posts/sourcekit_terminated.jpg" alt="sourcekit terminated" /></p>

<center><sub>Life would be miserable if Xcode crashed every time this appeared</sub></center>


<p><br/></p>

<h2>How Xcode uses SourceKit</h2>

<p>Since SourceKit is a private and undocumented tool, we need to get a little creative to learn how to use it. By setting the <code>SOURCEKIT_LOGGING</code><sup>2</sup> environment variable, Xcode will log its SourceKit communications to <code>stdout</code>, allowing us to monitor its communications in realtime. This is how many of the commands covered in this article were discovered.</p>

<h2>Unified Symbol Resolution</h2>

<p>SourceKit uses a Clang feature called the USR (Unified Symbol Resolution) as a unique identifier for a source code token (i.e. class, property, method, etc.). This is what allows you to <em>âŒ˜+click</em> any token in Xcode and navigate to its definition. The USR is even more powerful now that it can unify a representation across languages (Swift/ObjC).</p>

<p><img src="/images/posts/usr.jpg" alt="usr" /></p>

<center><sub>The USR at work</sub></center>


<p><br/></p>

<p>To print the USR's from a Swift file (and their locations), you can run the following command:</p>

<pre><code>$ xcrun swift-ide-test -print-usrs -source-filename=Musician.swift
10:7 s:C14swift_ide_test8Musician
14:9 s:vC14swift_ide_test8Musician4nameSS
19:9 s:vC14swift_ide_test8Musician9birthyearSu
33:5 s:FC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_
33:10 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4nameSS
33:24 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_9birthyearSu
34:9 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4selfS0_
34:21 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4nameSS
35:9 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_4selfS0_
35:26 s:vFC14swift_ide_test8MusiciancFMS0_FT4nameSS9birthyearSu_S0_L_9birthyearSu
</code></pre>

<h2>Swift<em>ish</em> header generation</h2>

<p><em>âŒ˜+clicking</em> on a token defined in Objective-C from Swift will cause Xcode to trigger a Swift-like header to be generated. I say Swift-like because this generated file is not valid Swift<sup>3</sup>, but at least displays the Swift syntax equivalent to the Objective-C tokens.</p>

<p><a href="/images/posts/generated_swift_header.jpg"><img src="/images/posts/generated_swift_header.jpg" alt="Generated Swift Header" /></a></p>

<center><sub>Left: original Objective-C header. Right: SourceKit-generated Swift-ish version.</sub></center>


<p><br/></p>

<h2>Using SourceKit from the command line</h2>

<p><img src="/images/posts/sourcekit_playground.jpg" alt="SourceKit Playground" /></p>

<p>There are 3 main command line tools that allow to interact with SourceKit: <code>sourcekitd-test</code>, <code>swift-ide-test</code> and <code>swift</code>.</p>

<p>I compiled a shell script with documentation that runs through many useful commands like syntax highlighting, interface generation, AST parsing, demangling, and more.</p>

<p>The script is available on GitHub as a <a href="https://gist.github.com/jpsim/13971c81445219db1c63#file-sourcekit_playground-sh">gist</a>.</p>

<h2>3rd Party Tools Using SourceKit</h2>

<p>Because SourceKit lives outside of Xcode, itâ€™s possible to leverage it to build anything from a Swift IDE to a documentation generator.</p>

<h3>jazzy<sup>â™ªâ™«</sup></h3>

<p><img src="/images/posts/jazzy.jpg" alt="jazzy" /></p>

<p><a href="https://github.com/realm/jazzy">jazzy</a> is a command-line utility that generates documentation for your Swift and Objective-C projects. It uses SourceKit to derive Swift syntax from Objective-C defined tokens (i.e. class, property, method, etc.).</p>

<h3>SwiftEdit</h3>

<p><a href="https://github.com/jpsim/SwiftEdit">SwiftEdit</a> is a proof-of-concept editor that supports syntax highlighting for Swift files.</p>

<p><img src="/images/posts/SwiftEdit.png" alt="SwiftEdit" /></p>

<h2>SourceKit &amp; You</h2>

<p>Weâ€™re just scratching the surface of whatâ€™s possible to build with SourceKit. Tools could be made to measure cross-language code coverage, or provide an editor where Objective-C and Swift can be edited simultaneously. Hopefully this article inspires you to build something with SourceKit and improve our tools in the process.</p>

<hr />

<p><em>1: Objective-C in Xcode 6 (Beta 2) doesn't use SourceKit at all, keeping Xcode's traditional clang-in-process architecture. I expect this to change before Xcode 6 GM.</em></p>

<p><em>2: For SourceKit logging, launch Xcode with <sub><code>export SOURCEKIT_LOGGING=3 &amp;&amp; /Applications/Xcode6-Beta2.app/Contents/MacOS/Xcode</code></sub></em></p>

<p><em>3: Speculation: I expect private Swift modules to expose public interfaces using a similar syntax once the language has <a href="https://github.com/ksm/SwiftInFlux#access-control">access control mechanisms</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SF Swift Meetup]]></title>
    <link href="https://jpsim.com/sf-swift-meetup/"/>
    <updated>2014-06-27T14:58:00-04:00</updated>
    <id>https://jpsim.com/sf-swift-meetup</id>
    <content type="html"><![CDATA[<p>I recently gave a talk on <a href="https://developer.apple.com/swift">Swift</a> at the <a href="http://www.meetup.com/swift-language">SF/SV Swift Language User Group</a> meetup. We've made the whole thing available online:</p>

<ul>
<li><a href="http://realm.io/news/swift-unchartered-territory-swift-intro-and-internals">Video</a></li>
<li><a href="https://speakerdeck.com/jpsim/swift-uncharted-territory">Slides</a></li>
<li><a href="https://github.com/jpsim/talks">Slides Source</a></li>
</ul>


<p>The first half of the talk covers the basic features and syntax of the language. The rest of the talk touches on some more in-depth discoveries about the runtime, introspection and how the tools work behind the scenes.</p>
]]></content>
  </entry>
  
</feed>
