<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocoapods | JP Simard]]></title>
  <link href="https://jpsim.com/categories/cocoapods/atom.xml" rel="self"/>
  <link href="https://jpsim.com/"/>
  <updated>2018-05-19T11:44:13+10:00</updated>
  <id>https://jpsim.com/</id>
  <author>
    <name><![CDATA[JP Simard]]></name>
    <email><![CDATA[jp@jpsim.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Private Pods]]></title>
    <link href="https://jpsim.com/private-pods/"/>
    <updated>2014-03-17T19:12:00+10:00</updated>
    <id>https://jpsim.com/private-pods</id>
    <content type="html"><![CDATA[<p>Keeping a project modular is a lofty software development goal that we all strive for even though it can never be fully attained.</p>

<p>One way to encourage a modular architecture is to use a dependency manager like <a href="http://cocoapods.org">Cocoapods</a>. I've blogged about using Cocoapods <a href="/cocoapods-tips-tricks">before</a>, but I didn't touch on splitting up portions of your code that wouldn't benefit from being open-sourced. Either because they're too application-specific, or they're proprietary.</p>

<p>For example, say you were building an application backed by a private web API, that needed to persist data to disk. A na√Øve implementation (<em>read what <strong>most</strong> of us would do, including myself</em>) would combine UI, API and persistence all in one project/workspace. In a fully modular app, UI/API/persistence would all have some degree of separation.</p>

<p>Private pods go a long way to help split up your codebase into logical modules. This becomes especially valuable in medium-large projects with 10k+ lines of code.</p>

<p>There are two main ways to make a private pod: remote and local.</p>

<h3>Remote</h3>

<p>You can either create a Specs-like private repo as indicated in <a href="http://guides.cocoapods.org/making/private-cocoapods.html">this official Cocoapods guide</a> or you can host your <code>.podspec</code> online and reference it directly in your <code>Podfile</code>.</p>

<p>Here's how you'd reference it directly in a <code>Podfile</code>:</p>

<pre><code class="ruby">pod 'PrivatePod', :podspec =&gt; 'https://github.com/jpsim/JPSDisplayLink/raw/master/JPSDisplayLink.podspec'
</code></pre>

<h3>Local</h3>

<p>Though I find it unlikely, it might make sense to keep your private pods in the same repo as your project. In which case, you'd commit all its code in a special folder (i.e. <code>local_pods/POD_NAME</code>) and you'd specify the podspec path in your <code>Podfile</code>.</p>

<pre><code class="ruby">pod 'PrivatePod', :path =&gt; 'local_pods/PrivatePod'
</code></pre>

<p>In this case, the <code>.podspec</code> would be located at <code>local_pods/PrivatePod/PrivatePod.podspec</code>.</p>

<p><em>Note: I've had inconsistent results writing local podspecs. Specs that worked perfectly in a remote repo didn't work at all locally for no apparent reason. Your mileage may vary, I might have made a stupid mistake.</em></p>

<h2>Word of caution</h2>

<p>Splitting up your codebase is not something you should do for its own sake. The additional overhead probably won't be worthwhile in smaller projects. But the larger the project, the bigger the gain.</p>

<p>On that note, I hope this article helps you decide how you want to split your monolithic 300k line app. But hey, you could always build static libraries instead (<em>cue laughter</em>).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods Tips & Tricks]]></title>
    <link href="https://jpsim.com/cocoapods-tips-tricks/"/>
    <updated>2014-03-12T09:45:00+10:00</updated>
    <id>https://jpsim.com/cocoapods-tips-tricks</id>
    <content type="html"><![CDATA[<p><a href="http://cocoapods.org">CocoaPods</a> documentation isn't very opiniated, which can cause confusion for newcomers. Here are a few tricks I've picked up after building a few dozen projects with CocoaPods.</p>

<h2>Source Control</h2>

<p>Should you check in <code>Podfile.lock</code>? How about your <code>*.xcworkspace</code> and the <code>Pods</code> directory? Since all of these are automatically generated by running <code>pod install</code>, is it redundant to also include them in your source control?</p>

<p>Some CocoaPods maintainers recommend to check everything in.</p>

<p>My approach is to check in <code>Podfile.lock</code> but not <code>xcworkspace</code> and <code>Pods</code>. Here's why:</p>

<h3>Podfile.lock</h3>

<p>Checking in <code>Podfile.lock</code> has the advantage of keeping track of the pod versions last used when working on the project. Also, if you run <code>pod install</code> and some pods have changed versions, you'll see the change in your next commit, encouraging you to confirm that nothing broke.</p>

<h3>Workspace</h3>

<p>In most cases, checking in the <code>*.xcworkspace</code> to source control is unnecessary, since <code>pod install</code> will automatically generate it for you. There are rare cases in which you need to customize it, in which case you should check it in.</p>

<h3>Pods Directory</h3>

<p>Checking in the <code>Pods</code> directory is a contested issue. Checking it in allows full control of the pods and will ensure you review every change to your vendored code. Not checking it in will keep your code more decoupled from its dependencies and clean up your commit logs. I don't do it because it ends up creating too many commit messages, especially if you're using a library which is updated very often, like <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>. Most dependency managers in other languages tend to not check in dependencies as well (i.e. npm &amp; rubygems).</p>

<h3>Finalizing a Project</h3>

<p>If I'm going to stop working on a project for a while, or I'm handing it off to a client, I'll create a branch with everything checked in. <code>Podfile.lock</code>, <code>*.xcworkspace</code> and <code>Pods</code>. This way, even if pods change over time, or they're removed from github, or whatever happens, I'm sure to have a working version of my project.</p>

<h3>Resources</h3>

<p>No matter what strategy you choose to take for CocoaPods SCM, be aware of the pros/cons of each.</p>

<p>Here are a few resources to help you decide:</p>

<ul>
<li><a href="https://github.com/CocoaPods/pod-template/blob/master/.gitignore">Official CocoaPods <code>.gitignore</code></a></li>
<li><a href="https://github.com/swizzlr/integer">CocoaPods plugin to maintain pod integrity</a></li>
<li><a href="https://twitter.com/simjp/status/443779386865500160">An interesting Twitter conversation about this article :)</a></li>
</ul>


<h2>Modifying Pods</h2>

<p>Before modifying a pod, ask yourself if it's necessary. Often, a category or subclass will do.</p>

<p>Pre-CocoaPods, when all vendored code was checked in, it was trivial to make small changes to 3rd party code. It's still easy now, but not as obvious. There are many ways to make changes to Pods in your project:</p>

<h3>1. Pull Request</h3>

<p>If your modifications are useful to other users of the 3rd party library, then consider submitting a <a href="https://help.github.com/articles/using-pull-requests">Pull Request</a>. This way, everyone benefits. Hopefully it will be merged quickly.</p>

<h3>2. Fork</h3>

<p>Certain projects are notorious for taking a long time to merge PR's (<a href="https://github.com/kif-framework/KIF">cough</a>). In those cases or cases when your PR's aren't accepted, it can be useful to just point your <code>Podfile</code> to your fork of the project. Add this to your <code>Podfile</code>:</p>

<pre><code class="ruby">pod 'KIF', :git =&gt; 'https://github.com/ksuther/KIF'
</code></pre>

<p>The downside to this approach is that you have to keep your fork up to date, which is where the patchfile approach comes in.</p>

<h3>3. Diffs</h3>

<p>If your modifications are small, I'd encourage you to use patchfiles (<code>*.diff</code>) to apply them to your pods. This will apply your modifications every time you run <code>pod install</code>, with the added benefit of using the latest upstream updates. To see how it works, take a look at this github project: <a href="https://github.com/jpsim/pod-diffs">jpsim/pod-diffs</a>.</p>

<p><em>Sidenote: patchfiles are super neat! Even if you modify code around your modification or the line numbers change, it's smart enought to find it again!</em></p>

<h3>4. Check it in</h3>

<p>This is a last resort. If all other methods fail, check in your vendored code into your project outside of CocoaPods. Then, you're free to modify it in any way you see fit. But then you need to update it manually when the upstream version changes.</p>

<h2>Continuous Integration &amp; Xcode Bots</h2>

<p>There's this misconception that using Xcode 5's <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html">Bots</a> feature for CI with CocoaPods projects means that you <strong>must</strong> check in your pods. In fact, Xcode Bots have the ability to run scripts prior to building your app. Check out <a href="https://gist.github.com/mtitolo/f5283c54e300d88d9418">this gist</a> for a comprehensive guide to Bots and CocoaPods.</p>

<hr />

<p><em>Thanks to @alloy, @aschndr, @ashfurrow &amp; @swizzlr for their feedback while writing this article</em></p>
]]></content>
  </entry>
  
</feed>
